// Generics demonstration

io :: import "std/io"

// Generic swap function
swap :: fn(a: ref $T, b: ref $T) {
    temp := a.val
    a.val = b.val
    b.val = temp
}

// Generic function
abs :: fn(x: $T) $T {
    ret if x < 0 { -x } else { x }
}

// Generic struct
Pair :: struct {
    first: $T
    second: $U
}

// Generic function for pairs
make_pair :: fn(first: $T, second: $U) Pair {
    ret Pair{first, second}
}

main :: fn() {
    // Test generic swap
    a := 10
    b := 20
    io.println("Before swap: a={}, b={}", a, b)
    swap(a.adr, b.adr)  // Type inferred
    io.println("After swap: a={}, b={}", a, b)

    // Test with different types
    x := 3.14
    y := 2.71
    io.println("Before swap: x={}, y={}", x, y)
    swap(x.adr, y.adr)  // Type inferred
    io.println("After swap: x={}, y={}", x, y)
    
    // Test generic abs function
    io.println("abs(-5) = {}", abs(-5))      // Type inferred
    io.println("abs(-3.14) = {}", abs(-3.14))  // Type inferred
    
    // Test generic struct
    int_string_pair := Pair{42, "answer"}
    io.println("Pair: ({}, {})", int_string_pair.first, int_string_pair.second)
    
    // Using generic function to create pair
    float_pair := make_pair(1.0, 2.0)
    io.println("Float pair: ({}, {})", float_pair.first, float_pair.second)
    
    // Generic with multiple type parameters
    map :: fn(arr: []$T, f: fn($T) $U) []$U {
        // This would need dynamic allocation in real implementation
        io.println("Map function called")
        ret nil  // Placeholder
    }
}
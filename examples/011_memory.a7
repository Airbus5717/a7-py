// A7 Memory Management with Property-Based Pointer Syntax
// Demonstrates heap allocation, deallocation, and the new .adr/.val syntax

main :: fn() {
    printf("=== A7 Memory Management with New Pointer Syntax ===\n\n")
    
    // Basic heap allocation and pointer usage
    printf("1. Basic Heap Allocation:\n")
    ptr := new i32              // Allocate single value on heap
    ptr.val = 42                // Set value using .val syntax
    defer del ptr               // Ensure cleanup with defer
    
    printf("   Allocated i32 on heap\n")
    printf("   ptr.val = {} (heap value via .val)\n", ptr.val)
    printf("   // Traditional: *ptr = 42; printf(\"%d\", *ptr);\n\n")
    
    // Array allocation with pointer access
    printf("2. Array Allocation:\n")
    nums := new [5]i32          // Allocate array on heap  
    defer del nums
    
    // Initialize array elements
    nums[0] = 10
    nums[1] = 20  
    nums[2] = 30
    nums[3] = 40
    nums[4] = 50
    
    printf("   Allocated [5]i32 array on heap\n")
    printf("   nums[0..2] = {} {} {}\n", nums[0], nums[1], nums[2])
    
    // Create pointer to specific array element
    elem_ptr: ref i32 = nums[2].adr    // Address of third element
    printf("   elem_ptr points to nums[2]\n")
    printf("   elem_ptr.val = {} (element via pointer)\n", elem_ptr.val)
    elem_ptr.val = 99           // Modify through pointer
    printf("   After elem_ptr.val = 99: nums[2] = {}\n", nums[2])
    printf("\n")
    
    // Struct allocation and pointer manipulation
    printf("3. Struct Allocation:\n")
    
    Person :: struct {
        name: string
        age: i32
        height: f64
    }
    
    person := new Person        // Allocate struct on heap
    defer del person
    
    person.val.name = "Alice"   // Access struct fields via .val
    person.val.age = 30
    person.val.height = 5.8
    
    printf("   Allocated Person struct on heap\n")  
    printf("   person.val.name = \"{}\"\n", person.val.name)
    printf("   person.val.age = {}\n", person.val.age)
    printf("   person.val.height = {}\n", person.val.height)
    
    // Create pointer to struct field
    age_ptr: ref i32 = person.val.age.adr  // Pointer to age field
    age_ptr.val += 1            // Happy birthday!
    printf("   After age_ptr.val += 1: age = {}\n", person.val.age)
    printf("\n")
    
    // Allocation failure handling
    printf("4. Allocation Failure Handling:\n")
    large_array := new [1000000]f64  // Try to allocate large array
    
    if large_array == nil {
        printf("   Large allocation failed (out of memory)\n")
    } else {
        printf("   Large allocation succeeded\n")
        large_array[0] = 1.0
        printf("   large_array[0] = {}\n", large_array[0])
        defer del large_array   // Clean up on success
    }
    printf("\n")
    
    // Nested scopes with automatic cleanup
    printf("5. Nested Scopes with Defer:\n")
    {
        printf("   Entering inner scope\n")
        temp1 := new f64
        defer del temp1
        temp1.val = 3.14159
        
        {
            printf("   Entering nested scope\n")
            temp2 := new f64  
            defer del temp2
            temp2.val = 2.71828
            
            printf("   temp1.val = {} (pi)\n", temp1.val)
            printf("   temp2.val = {} (e)\n", temp2.val)
            
            // Create pointer relationships
            pi_ptr: ref f64 = temp1.adr
            e_ptr: ref f64 = temp2.adr
            
            printf("   pi_ptr.val = {}\n", pi_ptr.val)
            printf("   e_ptr.val = {}\n", e_ptr.val)
            
            printf("   Exiting nested scope (temp2 freed)\n")
        }
        printf("   Back in inner scope\n")
        printf("   Exiting inner scope (temp1 freed)\n") 
    }
    printf("   Back in main scope\n\n")
    
    // Pointer sharing and aliasing
    printf("6. Pointer Sharing:\n")
    shared_value := new i32
    defer del shared_value
    shared_value.val = 100
    
    // Multiple pointers to same memory
    ptr1: ref i32 = shared_value   // Direct assignment (same pointer)
    ptr2: ref i32 = shared_value   // Another reference to same memory
    
    printf("   shared_value.val = {}\n", shared_value.val)
    printf("   ptr1.val = {}\n", ptr1.val) 
    printf("   ptr2.val = {}\n", ptr2.val)
    printf("   All point to same memory location\n")
    
    ptr1.val = 200              // Modify through first pointer
    printf("   After ptr1.val = 200:\n")
    printf("   shared_value.val = {}\n", shared_value.val)
    printf("   ptr2.val = {} (changed via ptr1)\n", ptr2.val)
    printf("\n")
    
    // Function with heap allocation
    printf("7. Function with Heap Memory:\n")
    
    create_and_fill :: fn(size: i32, value: i32) ref [10]i32 {
        arr := new [10]i32
        for i := 0; i < size; i += 1 {
            arr[i] = value * i
        }
        ret arr  // Return heap pointer (caller must free)
    }
    
    heap_array := create_and_fill(5, 10)
    defer del heap_array        // Caller responsible for cleanup
    
    printf("   Created array on heap in function\n")
    printf("   heap_array[0..4] = {} {} {} {} {}\n", 
           heap_array[0], heap_array[1], heap_array[2], heap_array[3], heap_array[4])
    printf("\n")
    
    // Defer execution order (LIFO)
    printf("8. Defer Execution Order (LIFO):\n")
    {
        printf("   Creating three heap allocations...\n")
        
        first := new i32
        first.val = 1
        defer {
            printf("   Freeing first (val = {})\n", first.val) 
            del first
        }
        
        second := new i32  
        second.val = 2
        defer {
            printf("   Freeing second (val = {})\n", second.val)
            del second
        }
        
        third := new i32
        third.val = 3  
        defer {
            printf("   Freeing third (val = {})\n", third.val)
            del third
        }
        
        printf("   All allocated. Exiting scope...\n")
        // Order will be: third, second, first (LIFO)
    }
    printf("   Back in main (all freed in reverse order)\n\n")
    
    printf("=== Memory Management Summary ===\n")
    printf("• new T: allocate on heap, returns pointer\n")
    printf("• del ptr: deallocate heap memory\n") 
    printf("• defer: ensures cleanup at scope exit\n")
    printf("• ptr.val: access heap value via pointer\n")
    printf("• variable.adr: get address for pointer\n")
    printf("• Always pair new/del to prevent leaks!\n")
    
    // Note: All remaining heap memory freed by defer statements
}
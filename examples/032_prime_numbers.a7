// Prime number algorithms

io :: import "std/io"

// Check if number is prime (trial division)
is_prime :: fn(n: i32) bool {
    if n <= 1 {
        ret false
    }
    if n <= 3 {
        ret true
    }
    if n % 2 == 0 or n % 3 == 0 {
        ret false
    }

    // Check divisors up to sqrt(n)
    i := 5
    while i * i <= n {
        if n % i == 0 or n % (i + 2) == 0 {
            ret false
        }
        i = i + 6
    }

    ret true
}

// Find nth prime number
nth_prime :: fn(n: i32) i32 {
    if n == 1 {
        ret 2
    }

    count := 1
    candidate := 3

    while count < n {
        if is_prime(candidate) {
            count += 1
        }
        if count < n {
            candidate += 2  // Only check odd numbers
        }
    }

    ret candidate
}

// Sieve of Eratosthenes - find all primes up to n
sieve_of_eratosthenes :: fn(n: i32, primes: []bool) i32 {
    // Initialize all as prime
    for i := 0; i <= n; i += 1 {
        primes[i] = true
    }

    primes[0] = false
    primes[1] = false

    p := 2
    while p * p <= n {
        if primes[p] {
            // Mark multiples of p as not prime
            for i := p * p; i <= n; i = i + p {
                primes[i] = false
            }
        }
        p += 1
    }

    // Count primes
    count := 0
    for i := 2; i <= n; i += 1 {
        if primes[i] {
            count += 1
        }
    }

    ret count
}

// Prime factorization
factorize :: fn(n: i32, factors: []i32) i32 {
    count := 0
    temp := n

    // Divide by 2
    while temp % 2 == 0 {
        factors[count] = 2
        count += 1
        temp /= 2
    }

    // Divide by odd numbers
    i := 3
    while i * i <= temp {
        while temp % i == 0 {
            factors[count] = i
            count += 1
            temp /= i
        }
        i = i + 2
    }

    // If remaining temp > 1, it's a prime factor
    if temp > 1 {
        factors[count] = temp
        count += 1
    }

    ret count
}

// Greatest Common Divisor (Euclidean algorithm)
gcd :: fn(a: i32, b: i32) i32 {
    while b != 0 {
        temp := b
        b = a % b
        a = temp
    }
    ret a
}

// Least Common Multiple
lcm :: fn(a: i32, b: i32) i32 {
    ret (a * b) / gcd(a, b)
}

main :: fn() {
    io.println("=== Prime Number Algorithms ===")
    io.println("")

    // Test primality
    io.println("Primality Test:")
    test_numbers: [10]i32  // Zero-initialized
    test_numbers[0] = 2
    test_numbers[1] = 7
    test_numbers[2] = 10
    test_numbers[3] = 17
    test_numbers[4] = 20
    test_numbers[5] = 29
    test_numbers[6] = 30
    test_numbers[7] = 37
    test_numbers[8] = 100
    test_numbers[9] = 101

    for num in test_numbers {
        result := if is_prime(num) { "prime" } else { "not prime" }
        io.println("  {} is {}", num, result)
    }
    io.println("")

    // Find nth primes
    io.println("Nth Primes:")
    for i := 1; i <= 10; i += 1 {
        io.println("  Prime #{} = {}", i, nth_prime(i))
    }
    io.println("")

    // Sieve of Eratosthenes
    io.println("Sieve of Eratosthenes (primes up to 100):")
    sieve: [101]bool  // Zero-initialized (false)
    prime_count := sieve_of_eratosthenes(100, sieve)
    io.println("  Found {} primes", prime_count)
    io.println("  Primes: ")
    count := 0
    for i := 2; i <= 100; i += 1 {
        if sieve[i] {
            io.println("    {}", i)
            count += 1
            if count >= 10 {  // Show first 10 only
                io.println("    ... and {} more", prime_count - 10)
                break
            }
        }
    }
    io.println("")

    // Prime factorization
    io.println("Prime Factorization:")
    numbers_to_factor: [5]i32  // Zero-initialized
    numbers_to_factor[0] = 12
    numbers_to_factor[1] = 24
    numbers_to_factor[2] = 60
    numbers_to_factor[3] = 100
    numbers_to_factor[4] = 315

    for num in numbers_to_factor {
        factors: [20]i32  // Zero-initialized
        factor_count := factorize(num, factors)
        io.println("  {} = ", num)
        for i := 0; i < factor_count; i += 1 {
            io.println("    {}", factors[i])
        }
    }
    io.println("")

    // GCD and LCM
    io.println("GCD and LCM:")
    io.println("  gcd(12, 18) = {}", gcd(12, 18))
    io.println("  lcm(12, 18) = {}", lcm(12, 18))
    io.println("  gcd(100, 50) = {}", gcd(100, 50))
    io.println("  lcm(100, 50) = {}", lcm(100, 50))
}

// Binary search tree implementation

io :: import "std/io"

// Binary tree node
TreeNode :: struct {
    value: i32
    left: ref TreeNode
    right: ref TreeNode
}

// Binary search tree
BinaryTree :: struct {
    root: ref TreeNode
    size: i32
}

// Create empty tree
create_tree :: fn() BinaryTree {
    ret BinaryTree{nil, 0}
}

// Insert value into tree
insert :: fn(tree: ref BinaryTree, value: i32) {
    new_node := new TreeNode
    new_node.val.value = value
    new_node.val.left = nil
    new_node.val.right = nil

    if tree.val.root == nil {
        tree.val.root = new_node
        tree.val.size = 1
        ret
    }

    // Find insertion point
    current := tree.val.root
    while true {
        if value < current.val.value {
            // Go left
            if current.val.left == nil {
                current.val.left = new_node
                tree.val.size += 1
                ret
            }
            current = current.val.left
        } else {
            // Go right
            if current.val.right == nil {
                current.val.right = new_node
                tree.val.size += 1
                ret
            }
            current = current.val.right
        }
    }
}

// Search for value in tree
search :: fn(tree: ref BinaryTree, value: i32) bool {
    current := tree.val.root

    while current != nil {
        if value == current.val.value {
            ret true
        } else if value < current.val.value {
            current = current.val.left
        } else {
            current = current.val.right
        }
    }

    ret false
}

// In-order traversal (left, root, right)
traverse_inorder :: fn(node: ref TreeNode, depth: i32) {
    if node == nil {
        ret
    }

    // Visit left subtree
    traverse_inorder(node.val.left, depth + 1)

    // Visit node
    indent := ""
    for i := 0; i < depth; i += 1 {
        indent = "  "
    }
    io.println("{}Value: {}", indent, node.val.value)

    // Visit right subtree
    traverse_inorder(node.val.right, depth + 1)
}

// Print tree
print_tree :: fn(tree: ref BinaryTree) {
    io.println("Binary Tree (size: {}):", tree.val.size)
    traverse_inorder(tree.val.root, 0)
}

// Find minimum value
find_min :: fn(node: ref TreeNode) i32 {
    if node == nil {
        ret -1
    }

    while node.val.left != nil {
        node = node.val.left
    }

    ret node.val.value
}

// Find maximum value
find_max :: fn(node: ref TreeNode) i32 {
    if node == nil {
        ret -1
    }

    while node.val.right != nil {
        node = node.val.right
    }

    ret node.val.value
}

// Free tree memory (post-order traversal)
free_tree :: fn(node: ref TreeNode) {
    if node == nil {
        ret
    }

    free_tree(node.val.left)
    free_tree(node.val.right)
    del node
}

main :: fn() {
    io.println("=== Binary Search Tree Example ===")

    tree := create_tree()
    tree_ref := tree.adr

    // Insert values
    insert(tree_ref, 50)
    insert(tree_ref, 30)
    insert(tree_ref, 70)
    insert(tree_ref, 20)
    insert(tree_ref, 40)
    insert(tree_ref, 60)
    insert(tree_ref, 80)

    print_tree(tree_ref)

    // Search
    io.println("Search 40: {}", search(tree_ref, 40))
    io.println("Search 99: {}", search(tree_ref, 99))

    // Min/Max
    io.println("Minimum: {}", find_min(tree.root))
    io.println("Maximum: {}", find_max(tree.root))

    // Cleanup
    free_tree(tree.root)
    io.println("Tree freed")
}

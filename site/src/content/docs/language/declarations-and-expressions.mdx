---
title: Declarations and Expressions
description: Variable declarations, declaration rules, and expression forms.
---

## Variable declarations

A7 supports mutable and immutable declarations.

```txt
x: i32 = 10      // explicit type
count := 42      // inferred type
const PI: f64 = 3.14159
var total: i64 = 0
```

## Declaration rules

Common rules used by compiler checks:

- Every identifier must be declared before use.
- Redeclaration in the same scope is rejected.
- Type inference (`:=`) requires a resolvable initializer.
- Assignment must satisfy type compatibility rules.

## Expression categories

### Primary expressions

- Identifiers
- Literals
- Parenthesized expressions

### Postfix expressions

- Function call: `f(x)`
- Indexing: `arr[i]`
- Member access: `obj.field`

### Unary expressions

Examples:

```txt
-neg
!flag
```

### Binary expressions

Examples:

```txt
a + b
x and y
left == right
```

### Cast expressions

Use `cast(TargetType, expr)` form.

```txt
n: i32 = cast(i32, value)
```

## Operator precedence (high-level)

1. Postfix (`call`, `index`, member access)
2. Unary
3. Multiplicative (`*`, `/`, `%`)
4. Additive (`+`, `-`)
5. Shift (`<<`, `>>`)
6. Comparison/equality
7. Logical (`and`, `or`)

## Practical recommendations

- Prefer explicit types at public API boundaries.
- Use inference for local values where type intent is obvious.
- Keep casts narrow and intentional.

---
title: Examples By Topic
description: Suggested reading order with inline source code for each example.
---

This page inlines the source for each example so you can study language patterns without leaving the docs.

Run any example:

```bash
uv run python main.py examples/001_hello.a7
```

## Fundamentals

### `001_hello.a7`

Hello World - The simplest A7 program

```txt
// Hello World - The simplest A7 program

io :: import "std/io"

main :: fn() {
    io.println("Hello, World!)
}

```

### `002_var.a7`

Variables and constants in A7

```txt
// Variables and constants in A7

io :: import "std/io"

main :: fn() {
    // Type-inferred variable (mutable)
    a := 1
    io.println("a = {} (inferred as i32)", a)

    // Constant (immutable)
    PI :: 3.14159
    io.println("PI = {}", PI)

    // Explicit type annotation
    count: i32 = 10
    io.println("count = {} (explicit i32)", count)

    // Multiple types
    name: string = "A7"
    active: bool = true
    ratio: f64 = 2.5

    io.println("name={}, active={}, ratio={}", name, active, ratio)

    // Variables can be reassigned
    count += 5
    io.println("count after increment = {}", count)

    // Uninitialized variable (defaults to zero)
    value: i32
    io.println("uninitialized value = {}", value)
}


```

### `003_comments.a7`

Comments in A7

```txt
// Comments in A7

// Single-line comments start with //
// They extend to the end of the line

/*
 * Multi-line comments use /* and */
 * They can span multiple lines
 * Useful for documentation blocks
 */

/* Multi-line comments can also be inline */

main :: fn() {
    x := 42  // Inline comment after code

    /*
     * Comments can be used to temporarily disable code:
     * y := 100
     * io.println("This won't run")
     */
}

/* Note: Multi-line comments do not need closing delimiter
 * if they extend to EOF (end of file)

```

### `004_func.a7`

Functions in A7

```txt
// Functions in A7

io :: import "std/io"

// Simple function with return value
add :: fn(x: i32, y: i32) i32 {
    ret x + y
}

// Function without return value (void)
greet :: fn(name: string) {
    io.println("Hello, {}!", name)
}

// Function with multiple return values (using inline struct)
divide :: fn(a: i32, b: i32) struct { quotient: i32, remainder: i32 } {
    ret struct { quotient: i32, remainder: i32 } {
        quotient: a / b,
        remainder: a % b
    }
}

// Recursive function
factorial :: fn(n: i32) i32 {
    if n <= 1 {
        ret 1
    }
    ret n * factorial(n - 1)
}

// Function with early return
max :: fn(a: i32, b: i32) i32 {
    if a > b {
        ret a
    }
    ret b
}

main :: fn() {
    io.println("=== Functions ===")

    // Call function with return value
    result := add(5, 7)
    io.println("5 + 7 = {}", result)

    // Call void function
    greet("World")

    // Function with multiple returns
    div_result := divide(17, 5)
    io.println("17 / 5 = {} remainder {}", div_result.quotient, div_result.remainder)

    // Recursive function
    io.println("5! = {}", factorial(5))

    // Max function
    io.println("max(10, 20) = {}", max(10, 20))
}

```

### `015_types.a7`

Type examples in A7

```txt
// Type examples in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Types ===")

    i: i32 = 42
    f: f64 = 3.5
    b: bool = true
    c: char = 'Z'
    s: string = "typed"

    io.println("i = {}", i)
    io.println("f = {}", f)
    io.println("b = {}", b)
    io.println("c = {}", c)
    io.println("s = {}", s)
}

```

### `019_literals.a7`

Literal values in A7

```txt
// Literal values in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Literals ===")

    i := 123
    f := 3.14159
    c: char = 'A'
    s: string = "hello"
    t := true
    n := nil

    io.println("int = {}", i)
    io.println("float = {}", f)
    io.println("char = {}", c)
    io.println("string = {}", s)
    io.println("bool = {}", t)
    io.println("nil = {}", n)
}

```

### `020_operators.a7`

Operators in A7

```txt
// Operators in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Operators ===")

    a := 10
    b := 3

    io.println("a + b = {}", a + b)
    io.println("a - b = {}", a - b)
    io.println("a * b = {}", a * b)
    io.println("a / b = {}", a / b)
    io.println("a % b = {}", a % b)

    io.println("a > b = {}", a > b)
    io.println("a == b = {}", a == b)

    io.println("a & b = {}", a & b)
    io.println("a | b = {}", a | b)
    io.println("a ^ b = {}", a ^ b)
    io.println("a << 1 = {}", a << 1)
    io.println("a >> 1 = {}", a >> 1)
}

```

## Control Flow

### `005_for_loop.a7`

For loops in A7

```txt
// For loops in A7

io :: import "std/io"

main :: fn() {
    io.println("=== For Loops ===")

    // C-style for loop
    io.println("Counting 0 to 4:")
    for i := 0; i < 5; i += 1 {
        io.println("  i = {}", i)
    }

    // Range-based for loop (iterate over array)
    numbers: [5]i32  // Zero-initialized
    numbers[0] = 10
    numbers[1] = 20
    numbers[2] = 30
    numbers[3] = 40
    numbers[4] = 50

    io.println("Array values:")
    for value in numbers {
        io.println("  value = {}", value)
    }

    // Range-based with index
    io.println("Array with indices:")
    for i, value in numbers {
        io.println("  [{}] = {}", i, value)
    }

    // Nested loops
    io.println("Multiplication table (3x3):")
    for i := 1; i <= 3; i += 1 {
        for j := 1; j <= 3; j += 1 {
            product := i * j
            io.println("  {} * {} = {}", i, j, product)
        }
    }

    // Loop with break
    io.println("Loop with break:")
    for i := 0; i < 10; i += 1 {
        if i == 5 {
            io.println("  Breaking at i = {}", i)
            break
        }
        io.println("  i = {}", i)
    }

    // Loop with continue
    io.println("Loop with continue (skip even numbers):")
    for i := 0; i < 6; i += 1 {
        if i % 2 == 0 {
            continue
        }
        io.println("  Odd: {}", i)
    }
}
```

### `006_if.a7`

If/else conditionals in A7

```txt
// If/else conditionals in A7

io :: import "std/io"

main :: fn() {
    io.println("=== If/Else Conditionals ===")

    // Simple if/else
    x := 10
    if x == 10 {
        io.println("x is 10")
    } else {
        io.println("x is not 10")
    }

    // If expression (ternary-like)
    result := if x > 0 { "positive" } else { "non-positive" }
    io.println("x is {}", result)

    // Else-if chain
    score := 85
    if score >= 90 {
        io.println("Grade: A")
    } else if score >= 80 {
        io.println("Grade: B")
    } else if score >= 70 {
        io.println("Grade: C")
    } else {
        io.println("Grade: F")
    }

    // Logical operators
    age := 25
    has_license := true

    if age >= 18 and has_license {
        io.println("Can drive")
    } else {
        io.println("Cannot drive")
    }

    // Nested conditions
    temperature := 22
    if temperature > 30 {
        io.println("Hot")
    } else {
        if temperature > 20 {
            io.println("Warm")
        } else {
            io.println("Cold")
        }
    }

    // Complex boolean expressions
    is_weekend := true
    is_holiday := false

    // Note: Complex parenthesized expressions with 'and' and '!' need work
    no_license := !has_license
    if (is_weekend or is_holiday) and no_license {
        io.println("Day off but can't drive")
    }
}

```

### `007_while.a7`

While loops in A7

```txt
// While loops in A7

io :: import "std/io"

main :: fn() {
    io.println("=== While Loops ===")

    // Basic while loop
    i := 0
    io.println("Counting with while loop:")
    while i < 5 {
        io.println("  i = {}", i)
        i += 1
    }

    // While with condition check
    count := 10
    io.println("Countdown:")
    while count > 0 {
        io.println("  {}", count)
        count -= 1
    }
    io.println("  Liftoff!")

    // While with break
    io.println("While with break:")
    n := 0
    while true {  // Infinite loop with break
        if n >= 5 {
            io.println("  Breaking at n = {}", n)
            break
        }
        io.println("  n = {}", n)
        n += 1
    }

    // While with continue
    io.println("While with continue (skip multiples of 3):")
    x := 0
    while x < 10 {
        x += 1
        if x % 3 == 0 {
            continue  // Skip printing multiples of 3
        }
        io.println("  {}", x)
    }

    // Sentinel-controlled loop
    io.println("Finding first power of 2 greater than 100:")
    power := 1
    exponent := 0
    while power <= 100 {
        exponent += 1
        power *= 2
    }
    io.println("  2^{} = {}", exponent, power)
}
```

### `008_switch.a7`

Match statements (switch-case) in A7

```txt
// Match statements (switch-case) in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Match Statements ===")

    day := 3
    match day {
        case 1: {
            io.println("Monday")
        }
        case 2: {
            io.println("Tuesday")
        }
        case 3: {
            io.println("Wednesday")
        }
        else: {
            io.println("Other day")
        }
    }
}

```

### `021_control_flow.a7`

Control flow in A7

```txt
// Control flow in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Control Flow ===")

    total := 0
    for i := 1; i <= 5; i += 1 {
        if i % 2 == 0 {
            continue
        }
        total += i
    }

    io.println("sum of odd numbers 1..5 = {}", total)

    n := 3
    while n > 0 {
        io.println("countdown: {}", n)
        n -= 1
    }
}

```

### `024_defer.a7`

Defer statement behavior

```txt
// Defer statement behavior

io :: import "std/io"

main :: fn() {
    io.println("=== Defer ===")

    defer io.println("cleanup step 1")
    defer io.println("cleanup step 2")

    io.println("doing work")
    io.println("about to return")
}

```

## Data Structures and Memory

### `009_struct.a7`

Structs in A7

```txt
// Structs in A7

io :: import "std/io"

Person :: struct {
    name: string
    age: i32
}

Employee :: struct {
    person: Person
    id: i32
}

main :: fn() {
    person := Person{name: "John", age: 30}
    emp := Employee{person: person, id: 7}

    io.println("=== Structs ===")
    io.println("Person: {} ({})", person.name, person.age)
    io.println("Employee id: {}", emp.id)
    io.println("Employee name: {}", emp.person.name)
}

```

### `010_enum.a7`

Enums in A7

```txt
// Enums in A7

io :: import "std/io"

Color :: enum {
    Red
    Green
    Blue
}

main :: fn() {
    io.println("=== Enums ===")
    color := Color.Green

    match color {
        case Color.Red: {
            io.println("Color is red")
        }
        case Color.Green: {
            io.println("Color is green")
        }
        case Color.Blue: {
            io.println("Color is blue")
        }
    }
}

```

### `011_memory.a7`

Memory management basics in A7

```txt
// Memory management basics in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Memory ===")

    value_ptr := new i32
    if value_ptr == nil {
        io.println("allocation failed")
        ret
    }

    value_ptr.val = 42
    io.println("heap value = {}", value_ptr.val)

    // Keep this example conservative and deterministic.
    io.println("memory example complete")
}

```

### `012_arrays.a7`

Arrays in A7

```txt
// Arrays in A7

io :: import "std/io"

main :: fn() {
    io.println("=== Arrays ===")

    numbers: [5]i32 = [10, 20, 30, 40, 50]

    sum := 0
    for i, value in numbers {
        io.println("numbers[{}] = {}", i, value)
        sum += value
    }

    io.println("sum = {}", sum)
}

```

### `013_pointers.a7`

Pointer syntax in A7

```txt
// Pointer syntax in A7

io :: import "std/io"

increment :: fn(p: ref i32) {
    p.val += 1
}

main :: fn() {
    io.println("=== Pointers ===")

    x: i32
    x = 10
    p: ref i32 = x.adr

    io.println("before = {}", x)
    increment(p)
    io.println("after = {}", x)
}

```

### `016_unions.a7`

Union declaration in A7

```txt
// Union declaration in A7

io :: import "std/io"

Value :: union {
    int_val: i32
    float_val: f64
}

main :: fn() {
    io.println("=== Unions ===")
    io.println("Union type declared successfully")
}

```

### `023_inline_structs.a7`

Inline-struct themed sample using named structs for runtime stability

```txt
// Inline-struct themed sample using named structs for runtime stability

io :: import "std/io"

Point :: struct {
    x: i32
    y: i32
}

Rect :: struct {
    w: i32
    h: i32
}

main :: fn() {
    io.println("=== Inline Structs ===")

    point := Point{x: 3, y: 4}
    rect := Rect{w: 7, h: 2}

    io.println("point = ({}, {})", point.x, point.y)
    io.println("area = {}", rect.w * rect.h)
}

```

### `025_linked_list.a7`

Linked-list themed sample

```txt
// Linked-list themed sample

io :: import "std/io"

main :: fn() {
    io.println("=== Linked List ===")

    values: [3]i32 = [10, 20, 30]
    for i, value in values {
        io.println("node {} = {}", i, value)
    }
}

```

### `026_binary_tree.a7`

Binary-tree themed sample

```txt
// Binary-tree themed sample

io :: import "std/io"

main :: fn() {
    io.println("=== Binary Tree ===")

    root := 10
    left := 5
    right := 15

    io.println("root = {}", root)
    io.println("left = {}", left)
    io.println("right = {}", right)
}

```

### `035_matrix.a7`

Matrix operations (flat arrays)

```txt
// Matrix operations (flat arrays)

io :: import "std/io"

main :: fn() {
    io.println("=== Matrix ===")

    a: [4]f64 = [1.0, 2.0, 3.0, 4.0]
    b: [4]f64 = [5.0, 6.0, 7.0, 8.0]
    c: [4]f64 = [0.0, 0.0, 0.0, 0.0]

    for i := 0; i < 4; i += 1 {
        c[i] = a[i] + b[i]
    }

    io.println("c00 = {}", c[0])
    io.println("c01 = {}", c[1])
    io.println("c10 = {}", c[2])
    io.println("c11 = {}", c[3])
}

```

## Functions and Abstractions

### `014_generics.a7`

Generics demonstration (minimal runnable sample)

```txt
// Generics demonstration (minimal runnable sample)

io :: import "std/io"

main :: fn() {
    io.println("=== Generics ===")
    io.println("Generic features are demonstrated in parser/semantic tests.")
}

```

### `017_methods.a7`

Method-style behavior using functions and ref parameters

```txt
// Method-style behavior using functions and ref parameters

io :: import "std/io"

Counter :: struct {
    value: i32
}

increment :: fn(counter: ref Counter) {
    counter.val.value += 1
}

main :: fn() {
    io.println("=== Methods ===")

    c := Counter{value: 0}
    c.value = 0
    increment(c.adr)
    increment(c.adr)

    io.println("counter = {}", c.value)
}

```

### `022_function_pointers.a7`

Function dispatch example (minimal runnable sample)

```txt
// Function dispatch example (minimal runnable sample)

io :: import "std/io"

add :: fn(a: i32, b: i32) i32 {
    ret a + b
}

sub :: fn(a: i32, b: i32) i32 {
    ret a - b
}

main :: fn() {
    io.println("=== Function Dispatch ===")

    use_add := true
    result := if use_add { add(8, 3) } else { sub(8, 3) }
    io.println("result = {}", result)
}

```

### `027_callbacks.a7`

Callback-style event handling (match-based)

```txt
// Callback-style event handling (match-based)

io :: import "std/io"

EventType :: enum {
    Click
    Submit
    Cancel
}

handle_event :: fn(event_type: EventType) {
    match event_type {
        case EventType.Click: {
            io.println("click handler")
        }
        case EventType.Submit: {
            io.println("submit handler")
        }
        case EventType.Cancel: {
            io.println("cancel handler")
        }
    }
}

main :: fn() {
    io.println("=== Callbacks ===")
    handle_event(EventType.Click)
    handle_event(EventType.Submit)
}

```

## Modules and Larger Programs

### `018_modules.a7`

Module imports in A7

```txt
// Module imports in A7

io :: import "std/io"
math :: import "std/math"

main :: fn() {
    io.println("=== Modules ===")

    x := 9.0
    io.println("sqrt({}) = {}", x, math.sqrt(x))
    io.println("abs(-5) = {}", math.abs(-5.0))
}

```

### `028_state_machine.a7`

State machine (match-driven)

```txt
// State machine (match-driven)

io :: import "std/io"

State :: enum {
    Idle
    Running
    Paused
    Stopped
}

transition :: fn(current: State, next: State) State {
    io.println("transition")
    match next {
        case State.Idle: {
            io.println("state: Idle")
        }
        case State.Running: {
            io.println("state: Running")
        }
        case State.Paused: {
            io.println("state: Paused")
        }
        case State.Stopped: {
            io.println("state: Stopped")
        }
    }
    ret next
}

main :: fn() {
    io.println("=== State Machine ===")

    state := State.Idle
    state = transition(state, State.Running)
    state = transition(state, State.Paused)
    state = transition(state, State.Stopped)

    io.println("done")
}

```

### `029_sorting.a7`

Sorting example with fixed array

```txt
// Sorting example with fixed array

io :: import "std/io"

main :: fn() {
    io.println("=== Sorting ===")

    arr: [5]i32 = [5, 1, 4, 2, 3]

    for i := 0; i < 5; i += 1 {
        for j := 0; j < 4 - i; j += 1 {
            if arr[j] > arr[j + 1] {
                temp := arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
        }
    }

    for i, value in arr {
        io.println("arr[{}] = {}", i, value)
    }
}

```

### `030_calculator.a7`

Simple calculator with multiple operations

```txt
// Simple calculator with multiple operations

io :: import "std/io"

// Calculator operations
add :: fn(a: f64, b: f64) f64 {
    ret a + b
}

subtract :: fn(a: f64, b: f64) f64 {
    ret a - b
}

multiply :: fn(a: f64, b: f64) f64 {
    ret a * b
}

divide :: fn(a: f64, b: f64) f64 {
    if b == 0.0 {
        io.println("Error: Division by zero!")
        ret 0.0
    }
    ret a / b
}

power :: fn(base: f64, exp: i32) f64 {
    if exp == 0 {
        ret 1.0
    }

    result := base
    for i := 1; i < exp; i += 1 {
        result *= base
    }
    ret result
}

// Calculate percentage
percentage :: fn(value: f64, total: f64) f64 {
    if total == 0.0 {
        ret 0.0
    }
    ret (value / total) * 100.0
}

// Square root approximation (Newton's method)
sqrt :: fn(x: f64) f64 {
    if x < 0.0 {
        io.println("Error: Cannot compute square root of negative number")
        ret 0.0
    }

    if x == 0.0 {
        ret 0.0
    }

    guess := x / 2.0
    epsilon := 0.00001

    for i := 0; i < 20; i += 1 {
        next_guess := (guess + x / guess) / 2.0
        diff := if (next_guess - guess) > 0.0 {
            next_guess - guess
        } else {
            guess - next_guess
        }

        if diff < epsilon {
            ret next_guess
        }
        guess = next_guess
    }

    ret guess
}

// Absolute value
abs :: fn(x: f64) f64 {
    ret if x < 0.0 { -x } else { x }
}

main :: fn() {
    io.println("=== Calculator ===")

    a := 10.0
    b := 3.0

    io.println("a = {}, b = {}", a, b)
    io.println("")

    // Basic operations
    io.println("Basic Operations:")
    io.println("  {} + {} = {}", a, b, add(a, b))
    io.println("  {} - {} = {}", a, b, subtract(a, b))
    io.println("  {} * {} = {}", a, b, multiply(a, b))
    io.println("  {} / {} = {}", a, b, divide(a, b))
    io.println("")

    // Power
    io.println("Power:")
    io.println("  {}^2 = {}", a, power(a, 2))
    io.println("  {}^3 = {}", a, power(a, 3))
    io.println("  2^10 = {}", power(2.0, 10))
    io.println("")

    // Square root
    io.println("Square Root:")
    io.println("  sqrt(16) = {}", sqrt(16.0))
    io.println("  sqrt(2) = {}", sqrt(2.0))
    io.println("  sqrt(100) = {}", sqrt(100.0))
    io.println("")

    // Percentage
    io.println("Percentages:")
    io.println("  25 is {}% of 100", percentage(25.0, 100.0))
    io.println("  75 is {}% of 150", percentage(75.0, 150.0))
    io.println("")

    // Absolute value
    io.println("Absolute Value:")
    io.println("  abs(-5.5) = {}", abs(-5.5))
    io.println("  abs(3.14) = {}", abs(3.14))

    // Complex calculation
    io.println("")
    io.println("Complex Calculation:")
    result := add(multiply(a, b), sqrt(16.0))
    io.println("  (a * b) + sqrt(16) = {}", result)
}

```

### `031_number_guessing.a7`

Deterministic number guessing demo

```txt
// Deterministic number guessing demo

io :: import "std/io"

main :: fn() {
    io.println("=== Number Guessing ===")

    target := 37
    guesses: [5]i32 = [10, 25, 37, 40, 50]

    won := false
    for i, guess in guesses {
        if won {
            break
        }

        io.println("attempt {} -> {}", i + 1, guess)
        if guess == target {
            io.println("correct")
            won = true
        } else if guess < target {
            io.println("too low")
        } else {
            io.println("too high")
        }
    }
}

```

### `032_prime_numbers.a7`

Prime number algorithms (minimal runnable sample)

```txt
// Prime number algorithms (minimal runnable sample)

io :: import "std/io"

is_prime :: fn(n: i32) bool {
    if n <= 1 {
        ret false
    }

    for d := 2; d * d <= n; d += 1 {
        if n % d == 0 {
            ret false
        }
    }

    ret true
}

gcd :: fn(a: i32, b: i32) i32 {
    x := a
    y := b

    while y != 0 {
        temp := y
        y = x % y
        x = temp
    }

    ret x
}

main :: fn() {
    io.println("=== Prime Numbers ===")

    for n := 2; n <= 20; n += 1 {
        if is_prime(n) {
            io.println("prime: {}", n)
        }
    }

    io.println("gcd(84, 30) = {}", gcd(84, 30))
}

```

### `033_fibonacci.a7`

Fibonacci sequence

```txt
// Fibonacci sequence

io :: import "std/io"

fib :: fn(n: i32) i32 {
    if n <= 1 {
        ret n
    }

    a := 0
    b := 1

    for i := 2; i <= n; i += 1 {
        next := a + b
        a = b
        b = next
    }

    ret b
}

main :: fn() {
    io.println("=== Fibonacci ===")

    for i := 0; i < 10; i += 1 {
        io.println("fib({}) = {}", i, fib(i))
    }
}

```

### `034_string_utils.a7`

String utility examples (deterministic)

```txt
// String utility examples (deterministic)

io :: import "std/io"

main :: fn() {
    io.println("=== String Utils ===")

    text: string = "Hello"
    io.println("text = {}", text)
    io.println("first char = {}", 'H')

    greeting := "Hello, A7"
    io.println("greeting = {}", greeting)
    io.println("string utilities complete")
}

```

## Suggested Progression

1. Start with Fundamentals.
2. Move to Control Flow and Data Structures.
3. Finish with Functions, Modules, and larger programs.
